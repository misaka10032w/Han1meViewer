I'll help you implement a comprehensive DeepL API-based translation system with caching, batching, and multi-key fallback. Here's a step-by-step guide:

Step 1: Create Translation Manager File

Create a new file: app/src/main/java/com/yenaly/han1meviewer/logic/TranslationManager.kt

```kotlin
package com.yenaly.han1meviewer.logic

import android.content.Context
import androidx.room.*
import com.yenaly.han1meviewer.Preferences
import com.yenaly.han1meviewer.logic.exception.TranslationException
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import okhttp3.*
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONArray
import org.json.JSONObject
import java.io.File
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicInteger
import kotlin.math.min

// ♧¥ separator for text blocks, { for tags
const val TEXT_SEPARATOR = "♧¥"
const val TAG_SEPARATOR = "{"

// Entity for translation cache
@Entity(tableName = "translation_cache")
data class TranslationCache(
    @PrimaryKey(autoGenerate = true) val id: Int = 0,
    val originalText: String,
    val translatedText: String,
    val sourceLang: String = "auto",
    val targetLang: String = "EN",
    val contentType: ContentType, // TITLE, DESCRIPTION, COMMENT, TAG, etc.
    val videoCode: String? = null,
    val timestamp: Long = System.currentTimeMillis(),
    val apiKeyUsed: String = "",
    val charsConsumed: Int = 0
) {
    enum class ContentType {
        TITLE, DESCRIPTION, COMMENT, TAG, ARTIST_NAME, OTHER
    }
}

// Dao for translation cache
@Dao
interface TranslationCacheDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(cache: TranslationCache)
    
    @Query("SELECT * FROM translation_cache WHERE originalText = :original AND targetLang = :targetLang AND contentType = :contentType")
    suspend fun get(original: String, targetLang: String, contentType: TranslationCache.ContentType): TranslationCache?
    
    @Query("SELECT * FROM translation_cache WHERE videoCode = :videoCode ORDER BY timestamp DESC")
    suspend fun getByVideoCode(videoCode: String): List<TranslationCache>
    
    @Query("SELECT * FROM translation_cache ORDER BY timestamp DESC")
    fun getAll(): Flow<List<TranslationCache>>
    
    @Query("DELETE FROM translation_cache WHERE id = :id")
    suspend fun delete(id: Int)
    
    @Query("DELETE FROM translation_cache WHERE contentType = :contentType")
    suspend fun deleteByType(contentType: TranslationCache.ContentType)
    
    @Query("DELETE FROM translation_cache")
    suspend fun deleteAll()
    
    @Query("SELECT SUM(charsConsumed) FROM translation_cache WHERE apiKeyUsed = :apiKey AND timestamp >= :startTime AND timestamp <= :endTime")
    suspend fun getCharsConsumed(apiKey: String, startTime: Long, endTime: Long): Long
}

// Database
@Database(entities = [TranslationCache::class], version = 1)
abstract class TranslationDatabase : RoomDatabase() {
    abstract fun cacheDao(): TranslationCacheDao
    
    companion object {
        @Volatile
        private var INSTANCE: TranslationDatabase? = null
        
        fun getInstance(context: Context): TranslationDatabase {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: Room.databaseBuilder(
                    context.applicationContext,
                    TranslationDatabase::class.java,
                    "translation.db"
                ).build().also { INSTANCE = it }
            }
        }
    }
}

// API Key with limits
data class TranslationApiKey(
    val key: String,
    val monthlyLimit: Int = 500000, // Default DeepL Free limit
    var charsUsedThisMonth: AtomicInteger = AtomicInteger(0),
    val isActive: Boolean = true,
    val lastReset: Long = System.currentTimeMillis()
) {
    fun resetIfNeeded(): Boolean {
        val now = System.currentTimeMillis()
        // Reset on 1st of every month
        val calendar = java.util.Calendar.getInstance()
        calendar.timeInMillis = lastReset
        val lastMonth = calendar.get(java.util.Calendar.MONTH)
        calendar.timeInMillis = now
        val currentMonth = calendar.get(java.util.Calendar.MONTH)
        
        if (currentMonth != lastMonth) {
            charsUsedThisMonth.set(0)
            return true
        }
        return false
    }
    
    fun hasQuota(chars: Int): Boolean {
        return charsUsedThisMonth.get() + chars <= monthlyLimit
    }
    
    fun consume(chars: Int) {
        charsUsedThisMonth.addAndGet(chars)
    }
}

// Main Translation Manager
class TranslationManager private constructor(context: Context) {
    private val cacheDao = TranslationDatabase.getInstance(context).cacheDao()
    private val client = OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .build()
    
    private var apiKeys = mutableListOf<TranslationApiKey>()
    private var currentApiKeyIndex = 0
    private var isEnabled = false
    private var batchSize = 30000 // 30KB limit per request
    private var targetLang = "EN"
    private var translateTitles = true
    private var translateDescriptions = true
    private var translateComments = true
    private var translateTags = true
    
    companion object {
        @Volatile
        private var INSTANCE: TranslationManager? = null
        
        fun getInstance(context: Context): TranslationManager {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: TranslationManager(context).also { INSTANCE = it }
            }
        }
    }
    
    // Initialize from preferences
    fun initialize() {
        val apiKeyStrings = Preferences.translationApiKeys
        apiKeys.clear()
        apiKeyStrings.forEach { key ->
            if (key.isNotBlank()) {
                apiKeys.add(TranslationApiKey(key, Preferences.translationMonthlyLimit))
            }
        }
        isEnabled = Preferences.isTranslationEnabled && apiKeys.isNotEmpty()
        targetLang = Preferences.translationTargetLang
        batchSize = Preferences.translationBatchSize
        translateTitles = Preferences.translateTitles
        translateDescriptions = Preferences.translateDescriptions
        translateComments = Preferences.translateComments
        translateTags = Preferences.translateTags
    }
    
    // Get next available API key
    private fun getNextApiKey(requestChars: Int): TranslationApiKey? {
        if (apiKeys.isEmpty()) return null
        
        // Try current key first
        for (i in 0 until apiKeys.size) {
            val index = (currentApiKeyIndex + i) % apiKeys.size
            val apiKey = apiKeys[index]
            
            if (apiKey.isActive && apiKey.hasQuota(requestChars)) {
                currentApiKeyIndex = index
                return apiKey
            }
        }
        
        // If no key has quota, try any active key (will exceed limit)
        for (apiKey in apiKeys) {
            if (apiKey.isActive) {
                return apiKey
            }
        }
        
        return null
    }
    
    // Make DeepL API call
    private suspend fun callDeepLApi(
        texts: List<String>,
        targetLang: String,
        sourceLang: String? = null
    ): List<String> {
        val apiKey = getNextApiKey(texts.sumOf { it.length }) ?: throw TranslationException("No available API key")
        
        val formBody = FormBody.Builder()
            .add("auth_key", apiKey.key)
            .add("target_lang", targetLang)
        
        sourceLang?.let { formBody.add("source_lang", it) }
        
        // Join texts with separator
        val joinedText = texts.joinToString(TEXT_SEPARATOR)
        formBody.add("text", joinedText)
        
        val request = Request.Builder()
            .url("https://api-free.deepl.com/v2/translate")
            .post(formBody.build())
            .build()
        
        return withContext(Dispatchers.IO) {
            client.newCall(request).execute().use { response ->
                if (!response.isSuccessful) {
                    throw TranslationException("API call failed: ${response.code}")
                }
                
                val body = response.body?.string() ?: throw TranslationException("Empty response")
                val json = JSONObject(body)
                val translations = json.getJSONArray("translations")
                
                val results = mutableListOf<String>()
                for (i in 0 until translations.length()) {
                    results.add(translations.getJSONObject(i).getString("text"))
                }
                
                // Split back using separator
                val allTranslated = if (results.isNotEmpty()) {
                    results.flatMap { it.split(TEXT_SEPARATOR) }
                } else {
                    emptyList()
                }
                
                // Record usage
                apiKey.consume(joinedText.length)
                
                allTranslated
            }
        }
    }
    
    // Smart batching
    private fun createBatches(texts: List<String>, maxBatchSize: Int = batchSize): List<List<String>> {
        val batches = mutableListOf<List<String>>()
        var currentBatch = mutableListOf<String>()
        var currentSize = 0
        
        for (text in texts) {
            val textSize = text.length
            
            // If single text is larger than batch size, split it
            if (textSize > maxBatchSize) {
                // First, add current batch if not empty
                if (currentBatch.isNotEmpty()) {
                    batches.add(currentBatch.toList())
                    currentBatch.clear()
                    currentSize = 0
                }
                
                // Split the large text
                val chunks = text.chunked(maxBatchSize - TEXT_SEPARATOR.length)
                for (chunk in chunks) {
                    if (currentSize + chunk.length + TEXT_SEPARATOR.length > maxBatchSize) {
                        batches.add(currentBatch.toList())
                        currentBatch.clear()
                        currentSize = 0
                    }
                    currentBatch.add(chunk)
                    currentSize += chunk.length + TEXT_SEPARATOR.length
                }
            } else {
                if (currentSize + textSize + TEXT_SEPARATOR.length > maxBatchSize) {
                    batches.add(currentBatch.toList())
                    currentBatch.clear()
                    currentSize = 0
                }
                currentBatch.add(text)
                currentSize += textSize + TEXT_SEPARATOR.length
            }
        }
        
        if (currentBatch.isNotEmpty()) {
            batches.add(currentBatch)
        }
        
        return batches
    }
    
    // Translate with caching
    suspend fun translate(
        originalText: String,
        contentType: TranslationCache.ContentType,
        videoCode: String? = null,
        forceFresh: Boolean = false
    ): String {
        if (!isEnabled || originalText.isBlank()) return originalText
        
        // Check cache first
        if (!forceFresh) {
            val cached = cacheDao.get(originalText, targetLang, contentType)
            if (cached != null) {
                return cached.translatedText
            }
        }
        
        // Skip if content type is disabled
        when (contentType) {
            TranslationCache.ContentType.TITLE -> if (!translateTitles) return originalText
            TranslationCache.ContentType.DESCRIPTION -> if (!translateDescriptions) return originalText
            TranslationCache.ContentType.COMMENT -> if (!translateComments) return originalText
            TranslationCache.ContentType.TAG -> if (!translateTags) return originalText
            else -> {}
        }
        
        return try {
            val translated = callDeepLApi(listOf(originalText), targetLang).firstOrNull() ?: originalText
            
            // Cache the result
            cacheDao.insert(
                TranslationCache(
                    originalText = originalText,
                    translatedText = translated,
                    targetLang = targetLang,
                    contentType = contentType,
                    videoCode = videoCode,
                    apiKeyUsed = apiKeys.getOrNull(currentApiKeyIndex)?.key ?: "",
                    charsConsumed = originalText.length
                )
            )
            
            translated
        } catch (e: Exception) {
            // Fallback: return original text
            e.printStackTrace()
            originalText
        }
    }
    
    // Batch translate multiple texts
    suspend fun translateBatch(
        texts: List<String>,
        contentType: TranslationCache.ContentType,
        videoCode: String? = null
    ): List<String> {
        if (!isEnabled || texts.isEmpty()) return texts
        
        val results = mutableListOf<String>()
        val toTranslate = mutableListOf<Pair<Int, String>>() // (index, text)
        
        // Check cache and collect texts that need translation
        texts.forEachIndexed { index, text ->
            if (text.isBlank()) {
                results.add(index, text)
            } else {
                val cached = cacheDao.get(text, targetLang, contentType)
                if (cached != null) {
                    results.add(index, cached.translatedText)
                } else {
                    toTranslate.add(index to text)
                }
            }
        }
        
        if (toTranslate.isEmpty()) return results
        
        // Prepare batches
        val textsToTranslate = toTranslate.map { it.second }
        val batches = createBatches(textsToTranslate)
        
        // Translate each batch
        for (batch in batches) {
            try {
                val translatedBatch = callDeepLApi(batch, targetLang)
                
                // Process results
                for ((batchIndex, translated) in translatedBatch.withIndex()) {
                    val originalIndex = toTranslate[batchIndex].first
                    results.add(originalIndex, translated)
                    
                    // Cache result
                    cacheDao.insert(
                        TranslationCache(
                            originalText = batch[batchIndex],
                            translatedText = translated,
                            targetLang = targetLang,
                            contentType = contentType,
                            videoCode = videoCode,
                            apiKeyUsed = apiKeys.getOrNull(currentApiKeyIndex)?.key ?: "",
                            charsConsumed = batch[batchIndex].length
                        )
                    )
                }
            } catch (e: Exception) {
                // If batch fails, add original texts
                e.printStackTrace()
                for ((index, text) in batch.withIndex()) {
                    results.add(toTranslate[index].first, text)
                }
            }
        }
        
        return results
    }
    
    // Translate tags (special handling)
    suspend fun translateTags(tags: List<String>, videoCode: String? = null): List<String> {
        if (!isEnabled || !translateTags || tags.isEmpty()) return tags
        
        // Join tags with separator
        val joinedTags = tags.joinToString(TAG_SEPARATOR)
        
        // Check cache for joined tags
        val cached = cacheDao.get(joinedTags, targetLang, TranslationCache.ContentType.TAG)
        if (cached != null) {
            return cached.translatedText.split(TAG_SEPARATOR)
        }
        
        return try {
            val translated = callDeepLApi(listOf(joinedTags), targetLang).firstOrNull() ?: joinedTags
            
            // Cache result
            cacheDao.insert(
                TranslationCache(
                    originalText = joinedTags,
                    translatedText = translated,
                    targetLang = targetLang,
                    contentType = TranslationCache.ContentType.TAG,
                    videoCode = videoCode,
                    apiKeyUsed = apiKeys.getOrNull(currentApiKeyIndex)?.key ?: "",
                    charsConsumed = joinedTags.length
                )
            )
            
            translated.split(TAG_SEPARATOR)
        } catch (e: Exception) {
            e.printStackTrace()
            tags
        }
    }
    
    // Get cache statistics
    suspend fun getStats(): Map<String, Any> {
        val allCache = cacheDao.getAll().first()
        val totalChars = allCache.sumOf { it.charsConsumed }
        val totalItems = allCache.size
        
        val byType = allCache.groupBy { it.contentType }
            .mapValues { it.value.size }
        
        val byApiKey = allCache.groupBy { it.apiKeyUsed }
            .mapValues { it.value.sumOf { cache -> cache.charsConsumed } }
        
        return mapOf(
            "totalChars" to totalChars,
            "totalItems" to totalItems,
            "byType" to byType,
            "byApiKey" to byApiKey,
            "apiKeys" to apiKeys.map { key ->
                mapOf(
                    "key" to key.key.take(8) + "..." + key.key.takeLast(4),
                    "monthlyLimit" to key.monthlyLimit,
                    "charsUsed" to key.charsUsedThisMonth.get(),
                    "remaining" to key.monthlyLimit - key.charsUsedThisMonth.get(),
                    "isActive" to key.isActive
                )
            }
        )
    }
    
    // Clear cache
    suspend fun clearCache() {
        cacheDao.deleteAll()
    }
    
    // Clear cache by type
    suspend fun clearCacheByType(contentType: TranslationCache.ContentType) {
        cacheDao.deleteByType(contentType)
    }
    
    // Delete specific cache item
    suspend fun deleteCacheItem(id: Int) {
        cacheDao.delete(id)
    }
    
    // Update settings
    fun updateSettings() {
        initialize()
    }
}
```

Step 2: Create Preferences Extension

Add to app/src/main/java/com/yenaly/han1meviewer/Preferences.kt:

```kotlin
// Translation preferences
var isTranslationEnabled by booleanPreference(false)
var translationApiKeys by stringSetPreference(setOf()) // Set of API keys
var translationMonthlyLimit by intPreference(500000)
var translationTargetLang by stringPreference("EN")
var translationBatchSize by intPreference(30000) // Max chars per request

// What to translate
var translateTitles by booleanPreference(true)
var translateDescriptions by booleanPreference(true)
var translateComments by booleanPreference(true)
var translateTags by booleanPreference(true)
```


changes of Constants.kt

package com.yenaly.han1meviewer

import kotlinx.datetime.LocalDate
import kotlinx.datetime.LocalDateTime
import kotlinx.datetime.format.char

/**
 * 我觉得空字符串写出来太逆天了，所以搞了个常量
 */
const val EMPTY_STRING = ""

const val APP_NAME = "Han1meViewer"

// 标准时间格式

/* yyyy-MM-dd */
@JvmField
val LOCAL_DATE_FORMAT = LocalDate.Formats.ISO

/* yyyy-MM-dd HH:mm */
@JvmField
val LOCAL_DATE_TIME_FORMAT = LocalDateTime.Format {
    date(LocalDate.Formats.ISO); char(' ')
    hour(); char(':'); minute()
}

// 网络基本设置

const val USER_AGENT =
    "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Mobile Safari/537.36"

// 設置發佈日期年份，在搜索的tag裏

/**
 * 發佈日期年份開始於
 */
const val SEARCH_YEAR_RANGE_START = 1990

/**
 * 發佈日期年份結束於
 */
const val SEARCH_YEAR_RANGE_END = BuildConfig.SEARCH_YEAR_RANGE_END

// intent傳值用名稱

const val FROM_DOWNLOAD = "FROM_DOWNLOAD"

const val VIDEO_CODE = "VIDEO_CODE"

//@Deprecated("Use [ADVANCED_SEARCH_MAP] instead")
//const val FROM_VIDEO_TAG = "FROM_VIDEO_TAG"

/**
 * 接受类型 [AdvancedSearchMap] 或者 [String]
 */
const val ADVANCED_SEARCH_MAP = "ADVANCED_SEARCH_MAP"

const val COMMENT_ID = "COMMENT_ID"

const val COMMENT_TYPE = "COMMENT_TYPE"

const val DATE_CODE = "DATE_CODE"

//const val CSRF_TOKEN = "CSRF_TOKEN"

// Result Code

//const val LOGIN_TO_MAIN_ACTIVITY = 0

// 给rv传值，判断布局需要wrap_content还是match_parent，不填则为默认
// 设置布局为MATCH_PARENT可以使rv在GridLayoutManager下能居中，反之不能

const val VIDEO_LAYOUT_WRAP_CONTENT = 1

const val VIDEO_LAYOUT_MATCH_PARENT = 2

// 給CommentFragment傳值，判斷是影片評論區還是預覽評論區 [COMMENT_TYPE]

const val VIDEO_COMMENT_PREFIX = "video"

const val PREVIEW_COMMENT_PREFIX = "preview"

// base url

@JvmField
val HANIME_BASE_URL = Preferences.baseUrl

/**
 * 如果添加备选网址别忘了改[String.toVideoCode]的videoUrlRegex
 * 没想弄动态匹配，觉得古法修改挺好的。
 */
object HanimeConstants {
    val HANIME_HOSTNAME = arrayOf("hanime1.me","hanime1.com","hanimeone.me","javchu.com")
    val HANIME_URL = arrayOf("https://hanime1.me/","https://hanime1.com/","https://hanimeone.me/","https://javchu.com/")
}

@JvmField
val HANIME_LOGIN_URL = HANIME_BASE_URL + "login"

// github url

const val HA1_GITHUB_URL = "https://github.com/misaka10032w/Han1meViewer"

const val HA1_GITHUB_ISSUE_URL = "$HA1_GITHUB_URL/issues"

const val HA1_GITHUB_FORUM_URL = "$HA1_GITHUB_URL/discussions"

const val HA1_GITHUB_RELEASES_URL = "$HA1_GITHUB_URL/releases"

const val HA1_GITHUB_API_URL = "https://api.github.com/repos/misaka10032w/Han1meViewer/"
const val FIREBASE_REALTIME_DATABASE = "https://han1meviewer-86e5f-default-rtdb.asia-southeast1.firebasedatabase.app/"

// for Shared Preference

const val LOGIN_COOKIE = "cookie"
const val SAVED_USER_ID = "saved_user_id"

const val CLOUDFLARE_COOKIE = "cf_cookie"

const val ALREADY_LOGIN = "already_login"

// 翻譯 相關 (Translation Constants)
const val IS_TRANSLATION_ENABLED = "is_translation_enabled"
const val TRANSLATION_API_KEYS = "translation_api_keys"
const val TRANSLATION_MONTHLY_LIMIT = "translation_monthly_limit"
const val TRANSLATION_TARGET_LANG = "translation_target_lang"
const val TRANSLATION_BATCH_SIZE = "translation_batch_size"
const val TRANSLATE_TITLES = "translate_titles"
const val TRANSLATE_DESCRIPTIONS = "translate_descriptions"
const val TRANSLATE_COMMENTS = "translate_comments"
const val TRANSLATE_TAGS = "translate_tags"

// Notification

const val DOWNLOAD_NOTIFICATION_CHANNEL = "download_channel"
const val UPDATE_NOTIFICATION_CHANNEL = "update_channel"

// File

const val FILE_PROVIDER_AUTHORITY = "${BuildConfig.APPLICATION_ID}.fileProvider"

update Prefereces.kt
// 翻譯 相關 (Translation Settings)

/**
 * Whether translation is enabled
 */
var isTranslationEnabled: Boolean
    get() = getSpValue(IS_TRANSLATION_ENABLED, false)
    set(value) = putSpValue(IS_TRANSLATION_ENABLED, value)

/**
 * DeepL API keys (set of strings)
 */
var translationApiKeys: Set<String>
    get() = getSpValue(TRANSLATION_API_KEYS, setOf<String>())
    set(value) = putSpValue(TRANSLATION_API_KEYS, value)

/**
 * Monthly character limit per API key
 */
var translationMonthlyLimit: Int
    get() = getSpValue(TRANSLATION_MONTHLY_LIMIT, 500000)
    set(value) = putSpValue(TRANSLATION_MONTHLY_LIMIT, value)

/**
 * Target language for translation (EN, DE, FR, etc.)
 */
var translationTargetLang: String
    get() = getSpValue(TRANSLATION_TARGET_LANG, "EN")
    set(value) = putSpValue(TRANSLATION_TARGET_LANG, value)

/**
 * Maximum characters per API request
 */
var translationBatchSize: Int
    get() = getSpValue(TRANSLATION_BATCH_SIZE, 30000)
    set(value) = putSpValue(TRANSLATION_BATCH_SIZE, value)

/**
 * Whether to translate titles
 */
var translateTitles: Boolean
    get() = getSpValue(TRANSLATE_TITLES, true)
    set(value) = putSpValue(TRANSLATE_TITLES, value)

/**
 * Whether to translate descriptions
 */
var translateDescriptions: Boolean
    get() = getSpValue(TRANSLATE_DESCRIPTIONS, true)
    set(value) = putSpValue(TRANSLATE_DESCRIPTIONS, value)

/**
 * Whether to translate comments
 */
var translateComments: Boolean
    get() = getSpValue(TRANSLATE_COMMENTS, true)
    set(value) = putSpValue(TRANSLATE_COMMENTS, value)

/**
 * Whether to translate tags
 */
var translateTags: Boolean
    get() = getSpValue(TRANSLATE_TAGS, true)
    set(value) = putSpValue(TRANSLATE_TAGS, value)
    

Step 3: Create Translation Settings Screen

Create app/src/main/java/com/yenaly/han1meviewer/ui/fragment/settings/TranslationSettingsFragment.kt:

```kotlin
package com.yenaly.han1meviewer.ui.fragment.settings

import android.os.Bundle
import android.view.View
import androidx.lifecycle.lifecycleScope
import androidx.preference.*
import com.yenaly.han1meviewer.Preferences
import com.yenaly.han1meviewer.R
import com.yenaly.yenaly_libs.base.settings.YenalySettingsFragment
import kotlinx.coroutines.launch

class TranslationSettingsFragment : YenalySettingsFragment() {
    
    override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
        setPreferencesFromResource(R.xml.preferences_translation, rootKey)
        
        // API Keys preference
        val apiKeysPref = findPreference<MultiSelectListPreference>("translation_api_keys")
        apiKeysPref?.setOnPreferenceChangeListener { _, newValue ->
            // Update API keys
            val keys = (newValue as Set<String>).toSet()
            Preferences.translationApiKeys = keys
            true
        }
        
        // Monthly limit
        val monthlyLimitPref = findPreference<EditTextPreference>("translation_monthly_limit")
        monthlyLimitPref?.setOnPreferenceChangeListener { _, newValue ->
            val limit = (newValue as String).toIntOrNull() ?: 500000
            Preferences.translationMonthlyLimit = limit
            true
        }
        
        // Batch size
        val batchSizePref = findPreference<EditTextPreference>("translation_batch_size")
        batchSizePref?.setOnPreferenceChangeListener { _, newValue ->
            val size = (newValue as String).toIntOrNull() ?: 30000
            Preferences.translationBatchSize = size
            true
        }
        
        // Target language
        val targetLangPref = findPreference<ListPreference>("translation_target_lang")
        targetLangPref?.setOnPreferenceChangeListener { _, newValue ->
            Preferences.translationTargetLang = newValue as String
            true
        }
        
        // What to translate
        val translateTitlesPref = findPreference<SwitchPreferenceCompat>("translate_titles")
        translateTitlesPref?.setOnPreferenceChangeListener { _, newValue ->
            Preferences.translateTitles = newValue as Boolean
            true
        }
        
        val translateDescriptionsPref = findPreference<SwitchPreferenceCompat>("translate_descriptions")
        translateDescriptionsPref?.setOnPreferenceChangeListener { _, newValue ->
            Preferences.translateDescriptions = newValue as Boolean
            true
        }
        
        val translateCommentsPref = findPreference<SwitchPreferenceCompat>("translate_comments")
        translateCommentsPref?.setOnPreferenceChangeListener { _, newValue ->
            Preferences.translateComments = newValue as Boolean
            true
        }
        
        val translateTagsPref = findPreference<SwitchPreferenceCompat>("translate_tags")
        translateTagsPref?.setOnPreferenceChangeListener { _, newValue ->
            Preferences.translateTags = newValue as Boolean
            true
        }
        
        // Clear cache button
        val clearCachePref = findPreference<Preference>("clear_translation_cache")
        clearCachePref?.setOnPreferenceClickListener {
            lifecycleScope.launch {
                // Get TranslationManager instance and clear cache
                // This will be implemented after creating Cache Management Fragment
                showSnackbar("Cache cleared")
            }
            true
        }
        
        // View cache button
        val viewCachePref = findPreference<Preference>("view_translation_cache")
        viewCachePref?.setOnPreferenceClickListener {
            // Navigate to Cache Management Fragment
            // This will be implemented
            true
        }
    }
}
```

Step 4: Create Translation Cache Management Screen

Create app/src/main/java/com/yenaly/han1meviewer/ui/fragment/TranslationCacheFragment.kt:

```kotlin
package com.yenaly.han1meviewer.ui.fragment

import android.os.Bundle
import android.view.*
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import com.yenaly.han1meviewer.R
import com.yenaly.han1meviewer.databinding.FragmentTranslationCacheBinding
import com.yenaly.han1meviewer.logic.TranslationCache
import com.yenaly.han1meviewer.logic.TranslationManager
import com.yenaly.han1meviewer.ui.adapter.TranslationCacheAdapter
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch

class TranslationCacheFragment : Fragment() {
    
    private var _binding: FragmentTranslationCacheBinding? = null
    private val binding get() = _binding!!
    private lateinit var adapter: TranslationCacheAdapter
    private lateinit var translationManager: TranslationManager
    
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentTranslationCacheBinding.inflate(inflater, container, false)
        return binding.root
    }
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        translationManager = TranslationManager.getInstance(requireContext())
        
        setupRecyclerView()
        setupToolbar()
        loadCache()
        setupFilterButtons()
    }
    
    private fun setupRecyclerView() {
        adapter = TranslationCacheAdapter(
            onEditClick = { cache ->
                // Show edit dialog
                showEditDialog(cache)
            },
            onDeleteClick = { cache ->
                lifecycleScope.launch {
                    translationManager.deleteCacheItem(cache.id)
                    loadCache()
                }
            }
        )
        
        binding.recyclerView.layoutManager = LinearLayoutManager(requireContext())
        binding.recyclerView.adapter = adapter
    }
    
    private fun setupToolbar() {
        binding.toolbar.title = getString(R.string.translation_cache)
        binding.toolbar.setNavigationOnClickListener {
            requireActivity().onBackPressed()
        }
        
        binding.toolbar.inflateMenu(R.menu.menu_translation_cache)
        binding.toolbar.setOnMenuItemClickListener { menuItem ->
            when (menuItem.itemId) {
                R.id.action_stats -> {
                    showStats()
                    true
                }
                R.id.action_clear_all -> {
                    lifecycleScope.launch {
                        translationManager.clearCache()
                        loadCache()
                    }
                    true
                }
                else -> false
            }
        }
    }
    
    private fun loadCache() {
        lifecycleScope.launch {
            val translationManager = TranslationManager.getInstance(requireContext())
            translationManager.cacheDao().getAll().collectLatest { cacheList ->
                adapter.submitList(cacheList)
                binding.emptyView.isVisible = cacheList.isEmpty()
                binding.recyclerView.isVisible = cacheList.isNotEmpty()
            }
        }
    }
    
    private fun setupFilterButtons() {
        val filters = mapOf(
            binding.btnAll to null,
            binding.btnTitles to TranslationCache.ContentType.TITLE,
            binding.btnDescriptions to TranslationCache.ContentType.DESCRIPTION,
            binding.btnComments to TranslationCache.ContentType.COMMENT,
            binding.btnTags to TranslationCache.ContentType.TAG
        )
        
        filters.forEach { (button, contentType) ->
            button?.setOnClickListener {
                // Highlight selected filter
                filters.keys.forEach { it?.isSelected = false }
                button.isSelected = true
                
                // Filter data
                lifecycleScope.launch {
                    val allCache = translationManager.cacheDao().getAll().first()
                    val filtered = if (contentType != null) {
                        allCache.filter { it.contentType == contentType }
                    } else {
                        allCache
                    }
                    adapter.submitList(filtered)
                    binding.emptyView.isVisible = filtered.isEmpty()
                    binding.recyclerView.isVisible = filtered.isNotEmpty()
                }
            }
        }
    }
    
    private fun showEditDialog(cache: TranslationCache) {
        // Create edit dialog
        // This is a simplified version - implement full dialog
    }
    
    private fun showStats() {
        lifecycleScope.launch {
            val stats = translationManager.getStats()
            
            val message = buildString {
                append("Total characters translated: ${stats["totalChars"]}\n")
                append("Total items cached: ${stats["totalItems"]}\n\n")
                
                append("By type:\n")
                (stats["byType"] as? Map<*, *>)?.forEach { (type, count) ->
                    append("  $type: $count\n")
                }
                
                append("\nAPI Key usage:\n")
                (stats["apiKeys"] as? List<*>)?.forEach { keyMap ->
                    val map = keyMap as Map<*, *>
                    append("  ${map["key"]}: ${map["charsUsed"]}/${map["monthlyLimit"]} (${map["remaining"]} remaining)\n")
                }
            }
            
            // Show dialog with stats
            android.app.AlertDialog.Builder(requireContext())
                .setTitle("Translation Statistics")
                .setMessage(message)
                .setPositiveButton("OK", null)
                .show()
        }
    }
    
    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
```

Step 5: Create Translation Cache Adapter

Create app/src/main/java/com/yenaly/han1meviewer/ui/adapter/TranslationCacheAdapter.kt:

```kotlin
package com.yenaly.han1meviewer.ui.adapter

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.yenaly.han1meviewer.R
import com.yenaly.han1meviewer.databinding.ItemTranslationCacheBinding
import com.yenaly.han1meviewer.logic.TranslationCache

class TranslationCacheAdapter(
    private val onEditClick: (TranslationCache) -> Unit,
    private val onDeleteClick: (TranslationCache) -> Unit
) : ListAdapter<TranslationCache, TranslationCacheAdapter.ViewHolder>(DiffCallback()) {
    
    class ViewHolder(
        private val binding: ItemTranslationCacheBinding,
        private val onEditClick: (TranslationCache) -> Unit,
        private val onDeleteClick: (TranslationCache) -> Unit
    ) : RecyclerView.ViewHolder(binding.root) {
        
        fun bind(cache: TranslationCache) {
            binding.apply {
                textOriginal.text = cache.originalText
                textTranslated.text = cache.translatedText
                textType.text = cache.contentType.name
                textLanguage.text = "${cache.sourceLang} → ${cache.targetLang}"
                textVideoCode.text = cache.videoCode ?: "N/A"
                textTimestamp.text = java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
                    .format(java.util.Date(cache.timestamp))
                
                // Show/hide translation on click
                itemView.setOnClickListener {
                    textTranslated.isVisible = !textTranslated.isVisible
                }
                
                // Edit button
                btnEdit.setOnClickListener {
                    onEditClick(cache)
                }
                
                // Delete button
                btnDelete.setOnClickListener {
                    onDeleteClick(cache)
                }
            }
        }
    }
    
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val binding = ItemTranslationCacheBinding.inflate(
            LayoutInflater.from(parent.context),
            parent,
            false
        )
        return ViewHolder(binding, onEditClick, onDeleteClick)
    }
    
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(getItem(position))
    }
    
    class DiffCallback : DiffUtil.ItemCallback<TranslationCache>() {
        override fun areItemsTheSame(oldItem: TranslationCache, newItem: TranslationCache): Boolean {
            return oldItem.id == newItem.id
        }
        
        override fun areContentsTheSame(oldItem: TranslationCache, newItem: TranslationCache): Boolean {
            return oldItem == newItem
        }
    }
}
```

Step 6: Create XML Resources

Create app/src/main/res/xml/preferences_translation.xml:

```xml
<?xml version="1.0" encoding="utf-8"?>
<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    
    <PreferenceCategory android:title="Translation Settings">
        
        <SwitchPreferenceCompat
            android:key="enable_translation"
            android:title="Enable Translation"
            android:summary="Enable automatic translation using DeepL API"
            android:defaultValue="false" />
        
        <EditTextPreference
            android:key="translation_api_keys"
            android:title="API Keys"
            android:summary="Enter DeepL API keys (one per line)"
            android:dialogTitle="Enter API Keys"
            android:dialogMessage="Enter DeepL API keys, one per line. First working key will be used."
            android:inputType="textMultiLine" />
        
        <EditTextPreference
            android:key="translation_monthly_limit"
            android:title="Monthly Character Limit"
            android:summary="Maximum characters per month per API key"
            android:dialogTitle="Monthly Limit"
            android:defaultValue="500000"
            android:inputType="number" />
        
        <ListPreference
            android:key="translation_target_lang"
            android:title="Target Language"
            android:summary="Language to translate to"
            android:entries="@array/translation_languages"
            android:entryValues="@array/translation_language_codes"
            android:defaultValue="EN" />
        
        <EditTextPreference
            android:key="translation_batch_size"
            android:title="Batch Size"
            android:summary="Maximum characters per API request"
            android:dialogTitle="Batch Size"
            android:defaultValue="30000"
            android:inputType="number" />
        
    </PreferenceCategory>
    
    <PreferenceCategory android:title="Translate Content">
        
        <SwitchPreferenceCompat
            android:key="translate_titles"
            android:title="Translate Titles"
            android:defaultValue="true" />
        
        <SwitchPreferenceCompat
            android:key="translate_descriptions"
            android:title="Translate Descriptions"
            android:defaultValue="true" />
        
        <SwitchPreferenceCompat
            android:key="translate_comments"
            android:title="Translate Comments"
            android:defaultValue="true" />
        
        <SwitchPreferenceCompat
            android:key="translate_tags"
            android:title="Translate Tags"
            android:defaultValue="true" />
        
    </PreferenceCategory>
    
    <PreferenceCategory android:title="Cache Management">
        
        <Preference
            android:key="view_translation_cache"
            android:title="View Translation Cache"
            android:summary="Browse and manage cached translations" />
        
        <Preference
            android:key="clear_translation_cache"
            android:title="Clear All Cache"
            android:summary="Delete all cached translations" />
        
        <Preference
            android:key="clear_titles_cache"
            android:title="Clear Titles Cache"
            android:summary="Delete cached title translations" />
        
        <Preference
            android:key="clear_descriptions_cache"
            android:title="Clear Descriptions Cache"
            android:summary="Delete cached description translations" />
        
        <Preference
            android:key="clear_comments_cache"
            android:title="Clear Comments Cache"
            android:summary="Delete cached comment translations" />
        
        <Preference
            android:key="clear_tags_cache"
            android:title="Clear Tags Cache"
            android:summary="Delete cached tag translations" />
        
    </PreferenceCategory>
    
    <PreferenceCategory android:title="Statistics">
        
        <Preference
            android:key="translation_stats"
            android:title="View Statistics"
            android:summary="View translation usage and API key statistics" />
        
    </PreferenceCategory>
    
</PreferenceScreen>
```

Create arrays in app/src/main/res/values/arrays.xml:

```xml
<resources>
    <string-array name="translation_languages">
        <item>English</item>
        <item>German</item>
        <item>French</item>
        <item>Spanish</item>
        <item>Portuguese</item>
        <item>Italian</item>
        <item>Dutch</item>
        <item>Polish</item>
        <item>Russian</item>
        <item>Japanese</item>
        <item>Chinese</item>
    </string-array>
    
    <string-array name="translation_language_codes">
        <item>EN</item>
        <item>DE</item>
        <item>FR</item>
        <item>ES</item>
        <item>PT</item>
        <item>IT</item>
        <item>NL</item>
        <item>PL</item>
        <item>RU</item>
        <item>JA</item>
        <item>ZH</item>
    </string-array>
</resources>
```

Step 7: Create Layout Files

Create app/src/main/res/layout/fragment_translation_cache.xml:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    
    <com.google.android.material.appbar.MaterialToolbar
        android:id="@+id/toolbar"
        android:layout_width="0dp"
        android:layout_height="?attr/actionBarSize"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:navigationIcon="?attr/homeAsUpIndicator" />
    
    <LinearLayout
        android:id="@+id/filterContainer"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center"
        android:padding="8dp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/toolbar">
        
        <Button
            android:id="@+id/btnAll"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="All"
            android:paddingStart="12dp"
            android:paddingEnd="12dp"
            android:layout_marginEnd="4dp"
            style="?attr/materialButtonOutlinedStyle" />
        
        <Button
            android:id="@+id/btnTitles"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Titles"
            android:paddingStart="12dp"
            android:paddingEnd="12dp"
            android:layout_marginEnd="4dp"
            style="?attr/materialButtonOutlinedStyle" />
        
        <Button
            android:id="@+id/btnDescriptions"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Descriptions"
            android:paddingStart="12dp"
            android:paddingEnd="12dp"
            android:layout_marginEnd="4dp"
            style="?attr/materialButtonOutlinedStyle" />
        
        <Button
            android:id="@+id/btnComments"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Comments"
            android:paddingStart="12dp"
            android:paddingEnd="12dp"
            android:layout_marginEnd="4dp"
            style="?attr/materialButtonOutlinedStyle" />
        
        <Button
            android:id="@+id/btnTags"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Tags"
            android:paddingStart="12dp"
            android:paddingEnd="12dp"
            style="?attr/materialButtonOutlinedStyle" />
        
    </LinearLayout>
    
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recyclerView"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:padding="8dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/filterContainer" />
    
    <TextView
        android:id="@+id/emptyView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="No cached translations"
        android:textSize="18sp"
        android:textStyle="italic"
        android:visibility="gone"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    
</androidx.constraintlayout.widget.ConstraintLayout>
```

Create app/src/main/res/layout/item_translation_cache.xml:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.cardview.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="4dp"
    app:cardCornerRadius="8dp"
    app:cardElevation="2dp">
    
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="12dp">
        
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginBottom="8dp">
            
            <TextView
                android:id="@+id/textType"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:background="?attr/selectableItemBackground"
                android:paddingHorizontal="8dp"
                android:paddingVertical="4dp"
                android:textSize="12sp"
                android:textStyle="bold" />
            
            <TextView
                android:id="@+id/textLanguage"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginStart="8dp"
                android:background="?attr/selectableItemBackground"
                android:paddingHorizontal="8dp"
                android:paddingVertical="4dp"
                android:textSize="12sp"
                android:textStyle="bold" />
            
            <TextView
                android:id="@+id/textVideoCode"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginStart="8dp"
                android:background="?attr/selectableItemBackground"
                android:paddingHorizontal="8dp"
                android:paddingVertical="4dp"
                android:textSize="12sp"
                android:textStyle="bold" />
            
            <Space
                android:layout_width="0dp"
                android:layout_height="0dp"
                android:layout_weight="1" />
            
            <TextView
                android:id="@+id/textTimestamp"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:textSize="12sp"
                android:textColor="?android:attr/textColorSecondary" />
            
        </LinearLayout>
        
        <TextView
            android:id="@+id/textOriginal"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textSize="14sp"
            android:textStyle="italic"
            android:textColor="?android:attr/textColorSecondary"
            android:layout_marginBottom="8dp" />
        
        <TextView
            android:id="@+id/textTranslated"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textSize="16sp"
            android:textStyle="bold"
            android:layout_marginBottom="8dp" />
        
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="end">
            
            <Button
                android:id="@+id/btnEdit"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Edit"
                android:paddingStart="12dp"
                android:paddingEnd="12dp"
                android:layout_marginEnd="8dp"
                style="?attr/materialButtonOutlinedStyle" />
            
            <Button
                android:id="@+id/btnDelete"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Delete"
                android:paddingStart="12dp"
                android:paddingEnd="12dp"
                style="?attr/materialButtonOutlinedStyle" />
            
        </LinearLayout>
        
    </LinearLayout>
    
</androidx.cardview.widget.CardView>
```

Step 8: Modify Parser to Use Translation

In Parser.kt, add translation calls:
package com.yenaly.han1meviewer.logic

import android.annotation.SuppressLint
import android.content.Context
import android.util.Log
import com.yenaly.han1meviewer.EMPTY_STRING
import com.yenaly.han1meviewer.HanimeConstants.HANIME_URL
import com.yenaly.han1meviewer.HanimeResolution
import com.yenaly.han1meviewer.LOCAL_DATE_FORMAT
import com.yenaly.han1meviewer.Preferences
import com.yenaly.han1meviewer.Preferences.isAlreadyLogin
import com.yenaly.han1meviewer.logic.exception.ParseException
import com.yenaly.han1meviewer.logic.model.HanimeInfo
import com.yenaly.han1meviewer.logic.model.HanimePreview
import com.yenaly.han1meviewer.logic.model.HanimeVideo
import com.yenaly.han1meviewer.logic.model.HomePage
import com.yenaly.han1meviewer.logic.model.MyListItems
import com.yenaly.han1meviewer.logic.model.MySubscriptions
import com.yenaly.han1meviewer.logic.model.Playlists
import com.yenaly.han1meviewer.logic.model.SubscriptionItem
import com.yenaly.han1meviewer.logic.model.SubscriptionVideosItem
import com.yenaly.han1meviewer.logic.model.VideoComments
import com.yenaly.han1meviewer.logic.state.PageLoadingState
import com.yenaly.han1meviewer.logic.state.VideoLoadingState
import com.yenaly.han1meviewer.logic.state.WebsiteState
import com.yenaly.han1meviewer.toVideoCode
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withContext
import kotlinx.datetime.LocalDate
import org.json.JSONObject
import org.jsoup.Jsoup
import org.jsoup.nodes.Comment
import org.jsoup.nodes.Element
import org.jsoup.select.Elements

/**
 * @project Han1meViewer
 * @author Yenaly Liew
 * @time 2023/07/31 031 16:43
 */
object Parser {

    /**
     * 所需 Regex
     */
    object Regex {
        val videoSource = Regex("""const source = '(.+)'""")
        val viewAndUploadTime = Regex("""(觀看次數|观看次数)：(.+)次 *(\d{4}-\d{2}-\d{2})""")
    }

    // Translation context holder
    private var translationContext: Context? = null

    /**
     * Initialize parser with context for translation
     */
    fun initialize(context: Context) {
        translationContext = context.applicationContext
    }

    /**
     * Helper to get translation manager if available
     */
    private suspend fun translateIfEnabled(
        text: String,
        contentType: TranslationCache.ContentType,
        videoCode: String? = null
    ): String {
        val context = translationContext ?: return text
        if (!Preferences.isTranslationEnabled || text.isBlank()) {
            return text
        }

        return try {
            val translationManager = TranslationManager.getInstance(context)
            translationManager.translate(text, contentType, videoCode)
        } catch (e: Exception) {
            Log.e("Parser", "Translation failed for ${contentType.name}: ${e.message}")
            text
        }
    }

    /**
     * Translate tags in batch
     */
    private suspend fun translateTagsIfEnabled(
        tags: List<String>,
        videoCode: String? = null
    ): List<String> {
        val context = translationContext ?: return tags
        if (!Preferences.isTranslationEnabled || !Preferences.translateTags || tags.isEmpty()) {
            return tags
        }

        return try {
            val translationManager = TranslationManager.getInstance(context)
            translationManager.translateTags(tags, videoCode)
        } catch (e: Exception) {
            Log.e("Parser", "Tag translation failed: ${e.message}")
            tags
        }
    }

    fun extractTokenFromLoginPage(body: String): String {
        val parseBody = Jsoup.parse(body).body()
        return parseBody.selectFirst("input[name=_token]")?.attr("value")
            ?: throw ParseException("Can't find csrf token from login page.")
    }

    fun homePageVer2(body: String): WebsiteState<HomePage> {
        val isAVSite = Preferences.baseUrl == HANIME_URL[3]
        val parseBody = Jsoup.parse(body).body()
        val csrfToken = parseBody.selectFirst("input[name=_token]")?.attr("value") // csrf token
        val homePageParse = parseBody.select("div[id=home-rows-wrapper] > div")

        // 用户信息
        val userInfo = parseBody.selectFirst("div[id=user-modal-dp-wrapper]")
        val avatarUrl: String? = userInfo?.selectFirst("img")?.absUrl("src")
        val username: String? = userInfo?.getElementById("user-modal-name")?.text()
        val userHomePageLink = parseBody.getElementById("user-modal-trigger")!!.attr("href")

        val userIdRegex = Regex("""/user/(\d+)""")
        val userId: String = userIdRegex.find(userHomePageLink)?.groupValues?.get(1) ?: ""
        Log.i("userInfo","name:$username;id:$userId")

        // 头图及其描述
        val bannerCSS = parseBody.selectFirst("div[id=home-banner-wrapper]")
        val bannerImg = bannerCSS?.previousElementSibling()
        val bannerTitle = bannerImg?.selectFirst("img")?.attr("alt")
            .logIfParseNull(Parser::homePageVer2.name, "bannerTitle")
        val bannerPic = bannerImg?.select("img")?.let { imgList ->
            imgList.getOrNull(1)?.absUrl("src") ?: imgList.getOrNull(0)?.absUrl("src")
        }?.logIfParseNull(Parser::homePageVer2.name, "bannerPic")
        val bannerDesc = bannerCSS?.selectFirst("h4")?.ownText()
        val bannerVideoCodeScript = parseBody.select("script")
            .firstOrNull{ it.data().contains("watch?v=")}
            ?.data()
        val regex = Regex("""watch\?v=(\d+)""")
        var bannerVideoCode = bannerVideoCodeScript?.let { script ->
            regex.find(script)?.groupValues?.get(1)
        }
        // 目前先判断注释里的，以后可能会有变化
        if (bannerVideoCode == null) {
            bannerCSS?.traverse { node, _ ->
                if (node is Comment) {
                    node.data.toVideoCode()?.let {
                        bannerVideoCode = it
                        return@traverse
                    }
                }
            }
        }
        bannerVideoCode.logIfParseNull(Parser::homePageVer2.name, "bannerVideoCode")
        
        // Translate banner title if enabled
        val translatedBannerTitle = bannerTitle?.let {
            runBlocking {
                translateIfEnabled(it, TranslationCache.ContentType.TITLE, bannerVideoCode)
            }
        } ?: bannerTitle
        
        val banner = if (bannerTitle != null && bannerPic != null) {
            HomePage.Banner(
                title = translatedBannerTitle ?: bannerTitle, 
                description = bannerDesc,
                picUrl = bannerPic, 
                videoCode = bannerVideoCode,
            )
        } else null

        // 主页模块
        val latestReleaseClass = homePageParse.getOrNull(0) // 最新上市
        val latestUploadClass = homePageParse.getOrNull(1)  //最新上传
        val ecchiAnimeClass = homePageParse.getOrNull(2)  //里番
        val shortEpisodeAnimeClass = homePageParse.getOrNull(3)  // 泡面番
        val motionAnimeClass = homePageParse.getOrNull(5)  // Motion Anime
        val threeDCGClass = homePageParse.getOrNull(6)  //3DCG
        val twoPointFiveDAnimeClass = homePageParse.getOrNull(7)  // 2.5D
        val twoDAnimeClass = homePageParse.getOrNull(8)  // 2D
        val aiGeneratedClass = homePageParse.getOrNull(10)  // AI生成
        val mmdClass = homePageParse.getOrNull(11)  //  MMD
        val cosplayClass = homePageParse.getOrNull(12)  // Cosplay
        val watchingNowClass = homePageParse.getOrNull(13)  // 他们在看

        val newAnimeTrailerClass = homePageParse.getOrNull(if (isAVSite) 13 else 12)

        val latestReleaseList = latestReleaseClass.extractHanimeInfo()
        val latestHanimeList = mutableListOf<HanimeInfo>()
        if (isAVSite){
            latestHanimeList.addAll(latestUploadClass.extractHanimeInfo())
        } else {
            latestHanimeList.addAll(latestUploadClass.extractHanimeInfo())
        }
        val ecchiAnimeList = ecchiAnimeClass.extractHanimeInfo()
        val shortEpisodeAnimeList = shortEpisodeAnimeClass.extractHanimeInfo()
        val motionAnimeList = motionAnimeClass.extractHanimeInfo()
        val threeDCGList = threeDCGClass.extractHanimeInfo()
        val twoPointFiveDAnimeList = twoPointFiveDAnimeClass.extractHanimeInfo()
        val twoDAnimeList = mutableListOf<HanimeInfo>()
        if (isAVSite){
            twoDAnimeList.addAll(twoDAnimeClass.extractHanimeInfo())
        } else {
            twoDAnimeList.addAll(twoDAnimeClass.extractHanimeInfo())
        }

        val aiGeneratedList = aiGeneratedClass.extractHanimeInfo()
        val mmdList = mmdClass.extractHanimeInfo()
        val cosplayList = cosplayClass.extractHanimeInfo()
        val watchingNowList = watchingNowClass.extractHanimeInfo()

        val newAnimeTrailerList = mutableListOf<HanimeInfo>()
        if (isAVSite){
            newAnimeTrailerList.addAll(newAnimeTrailerClass.extractHanimeInfo())
        } else {
            val newAnimeTrailerItems =
                newAnimeTrailerClass?.select("a")
            newAnimeTrailerItems?.forEach { newAnimeTrailerItem ->
                val videoCode = newAnimeTrailerItem.attr("href").toVideoCode()

                val coverUrl = newAnimeTrailerItem.selectFirst("img")?.attr("src")
                val title = newAnimeTrailerItem.selectFirst("div.home-rows-videos-title")?.text()
                if (title == null || coverUrl == null || videoCode == null) return@forEach
                
                // Translate title if enabled
                val translatedTitle = runBlocking {
                    translateIfEnabled(title, TranslationCache.ContentType.TITLE, videoCode)
                }
                
                newAnimeTrailerList.add(
                    HanimeInfo(
                        title = translatedTitle,
                        coverUrl = coverUrl,
                        videoCode = videoCode,
                        duration = "",
                        currentArtist = null,
                        views = null,
                        uploadTime = null,
                        genre = null,
                        itemType = HanimeInfo.SIMPLIFIED
                    )
                )
            }
        }

        // emit!
        return WebsiteState.Success(
            HomePage(
                csrfToken,
                avatarUrl, username, banner = banner,
                latestHanime = latestHanimeList,
                latestRelease = latestReleaseList,
                ecchiAnime = ecchiAnimeList,
                shortEpisodeAnime = shortEpisodeAnimeList,
                twoPointFiveDAnime = twoPointFiveDAnimeList,
                threeDCG = threeDCGList,
                motionAnime = motionAnimeList,
                twoDAnime = twoDAnimeList,
                aiGenerated = aiGeneratedList,
                mmd = mmdList,
                cosplay = cosplayList,
                watchingNow = watchingNowList,
                newAnimeTrailer = newAnimeTrailerList,
                userId = userId
            )
        )
    }
    
    fun Element?.extractHanimeInfo(selector: String = "div[class^=horizontal-card]"): MutableList<HanimeInfo> {
        val resultList = mutableListOf<HanimeInfo>()
        this?.select(selector)?.forEach { item ->
            hanimeNormalItemVer2(item)?.let { hanimeInfo ->
                resultList.add(hanimeInfo)
            }
        }
        return resultList
    }

    fun hanimeSearch(body: String): PageLoadingState<MutableList<HanimeInfo>> {
        val parseBody = Jsoup.parse(body).body()
        val allContentsClass =
            parseBody.getElementsByClass("content-padding-new").firstOrNull()
        val allSimplifiedContentsClass =
            parseBody.getElementsByClass("home-rows-videos-wrapper").firstOrNull()

        // emit!
        if (allContentsClass != null) {
            return hanimeSearchNormalVer2(allContentsClass)
        } else if (allSimplifiedContentsClass != null) {
            return hanimeSearchSimplified(allSimplifiedContentsClass)
        }
        return PageLoadingState.Success(mutableListOf())
    }

    private fun hanimeNormalItemVer2(hanimeSearchItem: Element): HanimeInfo? {
        val title =
            hanimeSearchItem.selectFirst("div.title, h4.video-title")?.text()?.trim()
                .logIfParseNull(Parser::hanimeNormalItemVer2.name, "title")
        val coverUrl =
            hanimeSearchItem.select("img").getOrNull(0)?.absUrl("src")
                .logIfParseNull(Parser::hanimeNormalItemVer2.name, "coverUrl")
        val videoCode =
            hanimeSearchItem.select("a").getOrNull(0)?.absUrl("href")?.toVideoCode()
                .logIfParseNull(Parser::hanimeNormalItemVer2.name, "videoCode")
        if (title == null || coverUrl == null || videoCode == null) return null
        val durationAndViews = hanimeSearchItem.select("div[class^=thumb-container]")
        val duration = durationAndViews.select("div[class^=duration]").text()
        val views = durationAndViews.select("div[class^=stat-item]").getOrNull(1)?.text()
        val artistAndUploadTime = hanimeSearchItem.selectFirst("div.subtitle a, div.video-meta-data a")!!.text().trim()
        var artist = ""
        var uploadTime = ""
        if (artistAndUploadTime.contains("•")) {
            val parts = artistAndUploadTime.split("•").map { it.trim() }
            artist = parts[0].trim()
            uploadTime = parts[1].trim()
        }
        val infoBoxes = hanimeSearchItem.selectFirst(".stats-container .stat-item")
        val fullText = infoBoxes?.text() ?: ""
        val reviews = fullText.replace("thumb_up", "").trim()
        
        // Translate title if enabled
        val translatedTitle = runBlocking {
            translateIfEnabled(title, TranslationCache.ContentType.TITLE, videoCode)
        }
        
        // Translate artist name if it's not empty
        val translatedArtist = if (artist.isNotBlank()) {
            runBlocking {
                translateIfEnabled(artist, TranslationCache.ContentType.ARTIST_NAME, videoCode)
            }
        } else artist
        
        return HanimeInfo(
            title = translatedTitle,
            coverUrl = coverUrl,
            videoCode = videoCode,
            duration = duration.logIfParseNull(Parser::hanimeNormalItemVer2.name, "duration"),
            currentArtist = translatedArtist,
            views = views.logIfParseNull(Parser::hanimeNormalItemVer2.name, "views"),
            uploadTime = uploadTime,
            genre = null,
            itemType = HanimeInfo.NORMAL,
            reviews = reviews
        )
    }

    // 每一个简化版视频单元
    private fun hanimeSimplifiedItem(hanimeSearchItem: Element): HanimeInfo? {
        val videoCode = hanimeSearchItem.attr("href").toVideoCode()
            .logIfParseNull(Parser::hanimeSimplifiedItem.name, "videoCode")
        val coverUrl = hanimeSearchItem.selectFirst("img")?.attr("src")
            .logIfParseNull(Parser::hanimeSimplifiedItem.name, "coverUrl")
        val title = hanimeSearchItem.selectFirst("div[class=home-rows-videos-title]")?.text()
            .logIfParseNull(Parser::hanimeSimplifiedItem.name, "title")
        if (videoCode == null || coverUrl == null || title == null) return null
        
        // Translate title if enabled
        val translatedTitle = runBlocking {
            translateIfEnabled(title, TranslationCache.ContentType.TITLE, videoCode)
        }
        
        return HanimeInfo(
            title = translatedTitle,
            coverUrl = coverUrl,
            videoCode = videoCode,
            itemType = HanimeInfo.SIMPLIFIED
        )
    }

    // 出来后是正常视频单元的页面用这个
    private fun hanimeSearchNormalVer2(
        allContentsClass: Element,
    ): PageLoadingState<MutableList<HanimeInfo>> {
        val hanimeSearchList = mutableListOf<HanimeInfo>()
        val hanimeSearchItems =
            allContentsClass.select("div[class^=horizontal-card]")
        if (hanimeSearchItems.isEmpty()) {
            return PageLoadingState.NoMoreData
        } else {
            hanimeSearchItems.forEach { hanimeSearchItem ->
                hanimeNormalItemVer2(hanimeSearchItem)?.let(hanimeSearchList::add)
            }
        }
        Log.d("search_result", "$hanimeSearchList")
        return PageLoadingState.Success(hanimeSearchList)
    }

    // 出来后是简化版视频单元的页面用这个
    private fun hanimeSearchSimplified(
        allSimplifiedContentsClass: Element,
    ): PageLoadingState<MutableList<HanimeInfo>> {
        val hanimeSearchList = mutableListOf<HanimeInfo>()
        val hanimeSearchItems = allSimplifiedContentsClass.children()
        if (hanimeSearchItems.isEmpty()) {
            return PageLoadingState.NoMoreData
        } else hanimeSearchItems.forEach { hanimeSearchItem ->
            hanimeSimplifiedItem(hanimeSearchItem)?.let(hanimeSearchList::add)
        }
        return PageLoadingState.Success(hanimeSearchList)
    }

    fun hanimeVideoVer2(body: String): VideoLoadingState<HanimeVideo> {
        val parseBody = Jsoup.parse(body).body()
        val csrfToken = parseBody.selectFirst("input[name=_token]")?.attr("value") // csrf token

        val currentUserId =
            parseBody.selectFirst("input[name=like-user-id]")?.attr("value") // current user id

        val title = parseBody.getElementById("shareBtn-title")?.text()
            .throwIfParseNull(Parser::hanimeVideoVer2.name, "title")

        var likeStatus = parseBody.selectFirst("[name=like-status]")
            ?.attr("value")
        Log.i("likeStatus", likeStatus.toString())
        if (!likeStatus.isNullOrEmpty()) {
            likeStatus = "1"
        }
        val likesCount = parseBody.selectFirst("input[name=likes-count]")
            ?.attr("value")?.toIntOrNull()
        val videoDetailWrapper = parseBody.selectFirst("div[class=video-details-wrapper]")
        val videoCaptionText = videoDetailWrapper?.selectFirst("div[class^=video-caption-text]")
        val chineseTitle = videoCaptionText?.previousElementSibling()?.ownText()
        val introduction = videoCaptionText?.ownText()
        val uploadTimeWithViews = videoDetailWrapper?.selectFirst("div > div > div")?.text()
        val uploadTimeWithViewsGroups = uploadTimeWithViews?.let {
            Regex.viewAndUploadTime.find(it)?.groups
        }
        val uploadTime = uploadTimeWithViewsGroups?.get(3)?.value?.let { time ->
            runCatching {
                LocalDate.parse(time, LOCAL_DATE_FORMAT)
            }.getOrNull()
        }

        val views = uploadTimeWithViewsGroups?.get(2)?.value

        val tags = parseBody.getElementsByClass("single-video-tag")
        val tagListWithLikeNum = mutableListOf<String>()
        tags.forEach { tag ->
            val child = tag.childOrNull(0)
            if (child != null && child.hasAttr("href")) {
                tagListWithLikeNum.add(child.text())
            }
        }
        val tagList = tagListWithLikeNum.map {
            it.substringBefore(" (")
                .removePrefix("#")
                .trim()
        }
        
        // Translate tags if enabled
        val translatedTags = runBlocking {
            translateTagsIfEnabled(tagList)
        }
        
        val myListCheckboxWrapper = parseBody.select("div[class~=playlist-checkbox-wrapper]")
        val myListInfo = mutableListOf<HanimeVideo.MyList.MyListInfo>()
        myListCheckboxWrapper.forEach {
            val listTitle = it.selectFirst("span")?.ownText()
                .logIfParseNull(Parser::hanimeVideoVer2.name, "myListTitle", loginNeeded = true)
            val listInput = it.selectFirst("input")
            val listCode = listInput?.attr("id")
                .logIfParseNull(Parser::hanimeVideoVer2.name, "myListCode", loginNeeded = true)
            val isSelected = listInput?.hasAttr("checked") == true
            if (listTitle != null && listCode != null) {
                myListInfo += HanimeVideo.MyList.MyListInfo(
                    code = listCode, title = listTitle, isSelected = isSelected
                )
            }
        }
        val isWatchLater = parseBody.getElementById("playlist-save-checkbox")
            ?.selectFirst("input")?.hasAttr("checked") == true
        val myList = HanimeVideo.MyList(isWatchLater = isWatchLater, myListInfo = myListInfo)

        val playlistWrapper = parseBody.selectFirst("div[id=video-playlist-wrapper]")
        val playlist = playlistWrapper?.let {
            val playlistVideoList = mutableListOf<HanimeInfo>()
            val playlistName = it.selectFirst("div > div > h4")?.text()
            val playlistScroll = it.getElementById("playlist-scroll")
            playlistScroll?.children()?.forEach { parent ->
                if (parent.tagName() == "a") {
                    return@forEach
                }
                val videoCode = parent.selectFirst("div > a")?.absUrl("href")?.toVideoCode()
                    .throwIfParseNull(Parser::hanimeVideoVer2.name, "videoCode")
                val cardMobilePanel = parent.selectFirst("div[class^=card-mobile-panel]")
                val eachTitleCover = cardMobilePanel?.select("div > div > div > img")?.getOrNull(1)
                val eachIsPlaying = cardMobilePanel?.select("div > div > div > div")
                    ?.firstOrNull()
                    ?.text()
                    ?.contains("播放") == true
                val cardMobileDuration = cardMobilePanel?.select("div[class*=card-mobile-duration]")
                val eachDuration = cardMobileDuration?.firstOrNull()?.text()
                val eachViews = cardMobileDuration?.getOrNull(2)?.text()
                    ?.substringBefore("次")
                val playlistEachCoverUrl = eachTitleCover?.absUrl("src")
                    .throwIfParseNull(Parser::hanimeVideoVer2.name, "playlistEachCoverUrl")
                val playlistEachTitle = eachTitleCover?.attr("alt")
                    .throwIfParseNull(Parser::hanimeVideoVer2.name, "playlistEachTitle")
                    
                // Translate playlist title if enabled
                val translatedPlaylistTitle = runBlocking {
                    translateIfEnabled(playlistEachTitle, TranslationCache.ContentType.TITLE, videoCode)
                }
                
                playlistVideoList.add(
                    HanimeInfo(
                        title = translatedPlaylistTitle, 
                        coverUrl = playlistEachCoverUrl,
                        videoCode = videoCode,
                        duration = eachDuration.logIfParseNull(
                            Parser::hanimeVideoVer2.name,
                            "$playlistEachTitle duration"
                        ),
                        views = eachViews.logIfParseNull(
                            Parser::hanimeVideoVer2.name,
                            "$playlistEachTitle views"
                        ),
                        isPlaying = eachIsPlaying,
                        itemType = HanimeInfo.NORMAL
                    )
                )
            }
            HanimeVideo.Playlist(playlistName = playlistName, video = playlistVideoList)
        }

        val relatedAnimeList = mutableListOf<HanimeInfo>()
        val relatedTabContent = parseBody.getElementById("related-tabcontent")

        relatedTabContent?.also {
            val children = it.childOrNull(0)?.children()
            val isSimplified =
                children?.getOrNull(0)?.select("a")?.getOrNull(0)
                    ?.getElementsByClass("home-rows-videos-div")
                    ?.firstOrNull() != null
            if (isSimplified) {
                for (each in children) {
                    val eachContent = each.selectFirst("a")
                    val homeRowsVideosDiv =
                        eachContent?.getElementsByClass("home-rows-videos-div")?.firstOrNull()

                    if (homeRowsVideosDiv != null) {
                        val eachVideoCode = eachContent.absUrl("href").toVideoCode() ?: continue
                        val eachCoverUrl = homeRowsVideosDiv.selectFirst("img")?.absUrl("src")
                            .throwIfParseNull(Parser::hanimeVideoVer2.name, "eachCoverUrl")
                        val eachTitle =
                            homeRowsVideosDiv.selectFirst("div[class$=title]")?.text()
                                .throwIfParseNull(Parser::hanimeVideoVer2.name, "eachTitle")
                        
                        // Translate related anime title if enabled
                        val translatedEachTitle = runBlocking {
                            translateIfEnabled(eachTitle, TranslationCache.ContentType.TITLE, eachVideoCode)
                        }
                        
                        relatedAnimeList.add(
                            HanimeInfo(
                                title = translatedEachTitle, 
                                coverUrl = eachCoverUrl,
                                videoCode = eachVideoCode,
                                itemType = HanimeInfo.SIMPLIFIED
                            )
                        )
                    }
                }
            } else {
                relatedTabContent.extractHanimeInfo().forEach { info ->
                    // Translate title for each related anime
                    val translatedTitle = runBlocking {
                        translateIfEnabled(info.title, TranslationCache.ContentType.TITLE, info.videoCode)
                    }
                    relatedAnimeList.add(info.copy(title = translatedTitle))
                }
            }
        }
        Log.d("related_anime_list", relatedAnimeList.toString())

        val hanimeResolution = HanimeResolution()
        val videoClass = parseBody.selectFirst("video[id=player]")
        val videoCoverUrl = videoClass?.absUrl("poster").orEmpty()
        val videos = videoClass?.children()
        if (!videos.isNullOrEmpty()) {
            videos.forEach { source ->
                val resolution = source.attr("size") + "P"
                val sourceUrl = source.absUrl("src")
                val videoType = source.attr("type")
                hanimeResolution.parseResolution(resolution, sourceUrl, videoType)
            }
        } else {
            val playerDivWrapper = parseBody.selectFirst("div[id=player-div-wrapper]")
            playerDivWrapper?.select("script")?.let { scripts ->
                for (script in scripts) {
                    val data = script.data()
                    if (data.isBlank()) continue
                    val result =
                        Regex.videoSource.find(data)?.groups?.get(1)?.value ?: continue
                    hanimeResolution.parseResolution(null, result)
                    break
                }
            }
        }

        val artistAvatarUrl = parseBody
            .select("div.video-details-wrapper > div > a > div > img[style*='position: absolute'][style*='border-radius: 50%']")
            .attr("src")
        val artistNameCSS = parseBody.getElementById("video-artist-name")
        val artistGenre = artistNameCSS?.nextElementSibling()?.text()?.trim()
        val artistName = artistNameCSS?.text()?.trim()
        val postCSS = parseBody.getElementById("video-subscribe-form")
        val post = postCSS?.let {
            val userId = it.selectFirst("input[name=subscribe-user-id]")?.attr("value")
            val artistId = it.selectFirst("input[name=subscribe-artist-id]")?.attr("value")
            val isSubscribed = it.selectFirst("input[name=subscribe-status]")?.attr("value")
            if (userId != null && artistId != null && isSubscribed != null) {
                HanimeVideo.Artist.POST(
                    userId = userId,
                    artistId = artistId,
                    isSubscribed = isSubscribed == "1"
                )
            } else null
        }
        
        // Translate artist name and genre if enabled
        val translatedArtistName = artistName?.let {
            runBlocking {
                translateIfEnabled(it, TranslationCache.ContentType.ARTIST_NAME)
            }
        } ?: artistName
        
        val translatedArtistGenre = artistGenre?.let {
            runBlocking {
                translateIfEnabled(it, TranslationCache.ContentType.OTHER)
            }
        } ?: artistGenre
        
        val artist = if (artistName != null && artistGenre != null) {
            HanimeVideo.Artist(
                name = translatedArtistName ?: artistName,
                avatarUrl = artistAvatarUrl,
                genre = translatedArtistGenre ?: artistGenre,
                post = post,
            )
        } else null
        val originalComic = parseBody.selectFirst("a.video-comic-btn")?.attr("href")

        // Translate main content
        val translatedTitle = runBlocking {
            translateIfEnabled(title, TranslationCache.ContentType.TITLE)
        }
        
        val translatedChineseTitle = chineseTitle?.let {
            runBlocking {
                translateIfEnabled(it, TranslationCache.ContentType.DESCRIPTION)
            }
        }
        
        val translatedIntroduction = introduction?.let {
            runBlocking {
                translateIfEnabled(it, TranslationCache.ContentType.DESCRIPTION)
            }
        }

        return VideoLoadingState.Success(
            HanimeVideo(
                title = translatedTitle, 
                coverUrl = videoCoverUrl,
                chineseTitle = translatedChineseTitle?.logIfParseNull(
                    Parser::hanimeVideoVer2.name,
                    "chineseTitle"
                ),
                uploadTime = uploadTime.logIfParseNull(Parser::hanimeVideoVer2.name, "uploadTime"),
                views = views.logIfParseNull(Parser::hanimeVideoVer2.name, "views"),
                introduction = translatedIntroduction?.logIfParseNull(
                    Parser::hanimeVideoVer2.name,
                    "introduction"
                ),
                videoUrls = hanimeResolution.toResolutionLinkMap(),
                tags = translatedTags,
                myList = myList,
                playlist = playlist,
                relatedHanimes = relatedAnimeList,
                artist = artist.logIfParseNull(Parser::hanimeVideoVer2.name, "artist"),
                favTimes = likesCount,
                isFav = likeStatus == "1",
                csrfToken = csrfToken,
                currentUserId = currentUserId,
                originalComic = originalComic
            )
        )
    }

    fun hanimePreview(body: String): WebsiteState<HanimePreview> {
        val parseBody = Jsoup.parse(body).body()

        // latest hanime
        val latestHanimeList = mutableListOf<HanimeInfo>()
        val latestHanimeClass = parseBody.selectFirst("div[class$=owl-theme]")
        latestHanimeClass?.let {
            val latestHanimeItems = latestHanimeClass.select("div[class=home-rows-videos-div]")
            latestHanimeItems.forEach { latestHanimeItem ->
                val coverUrl = latestHanimeItem.selectFirst("img")?.absUrl("src")
                    .throwIfParseNull(Parser::hanimePreview.name, "coverUrl")
                val title = latestHanimeItem.selectFirst("div[class$=title]")?.text()
                    .throwIfParseNull(Parser::hanimePreview.name, "title")
                    
                // Translate title if enabled
                val translatedTitle = runBlocking {
                    translateIfEnabled(title, TranslationCache.ContentType.TITLE)
                }
                
                latestHanimeList.add(
                    HanimeInfo(
                        coverUrl = coverUrl,
                        title = translatedTitle,
                        videoCode = EMPTY_STRING /* empty string here! */,
                        itemType = HanimeInfo.SIMPLIFIED
                    )
                )
            }
        }

        val contentPaddingClass = parseBody.select("div[class=content-padding] > div")
        val previewInfo = mutableListOf<HanimePreview.PreviewInfo>()
        for (i in 0 until contentPaddingClass.size / 2) {

            val firstPart = contentPaddingClass.getOrNull(i * 2)
            val secondPart = contentPaddingClass.getOrNull(i * 2 + 1)

            val videoCode = firstPart?.id()
            val title = firstPart?.selectFirst("h4")?.text()
            val coverUrl =
                firstPart?.selectFirst("div[class=preview-info-cover] > img")?.absUrl("src")
            val previewInfoContentClass =
                firstPart?.getElementsByClass("preview-info-content-padding")?.firstOrNull()
            val videoTitle = previewInfoContentClass?.selectFirst("h4")?.text()
            val brand = previewInfoContentClass?.selectFirst("h5")?.selectFirst("a")?.text()
            val releaseDate = previewInfoContentClass?.select("h5")?.getOrNull(1)?.ownText()

            val introduction = secondPart?.selectFirst("h5")?.text()
            val tagClass = secondPart?.select("div[class=single-video-tag] > a")
            val tags = mutableListOf<String>()
            tagClass?.forEach { tag: Element? ->
                tag?.let { tags.add(tag.text()) }
            }
            val relatedPicClass = secondPart?.select("img[class=preview-image-modal-trigger]")
            val relatedPics = mutableListOf<String>()
            relatedPicClass?.forEach { relatedPic: Element? ->
                relatedPic?.let { relatedPics.add(relatedPic.absUrl("src")) }
            }
            
            // Translate content if enabled
            val translatedTitle = title?.let {
                runBlocking {
                    translateIfEnabled(it, TranslationCache.ContentType.TITLE, videoCode)
                }
            } ?: title
            
            val translatedVideoTitle = videoTitle?.let {
                runBlocking {
                    translateIfEnabled(it, TranslationCache.ContentType.TITLE, videoCode)
                }
            } ?: videoTitle
            
            val translatedBrand = brand?.let {
                runBlocking {
                    translateIfEnabled(it, TranslationCache.ContentType.OTHER, videoCode)
                }
            } ?: brand
            
            val translatedIntroduction = introduction?.let {
                runBlocking {
                    translateIfEnabled(it, TranslationCache.ContentType.DESCRIPTION, videoCode)
                }
            } ?: introduction
            
            // Translate tags if enabled
            val translatedTags = if (tags.isNotEmpty()) {
                runBlocking {
                    translateTagsIfEnabled(tags, videoCode)
                }
            } else tags

            previewInfo.add(
                HanimePreview.PreviewInfo(
                    title = translatedTitle,
                    videoTitle = translatedVideoTitle,
                    coverUrl = coverUrl,
                    introduction = translatedIntroduction.logIfParseNull(
                        Parser::hanimePreview.name,
                        "$title introduction"
                    ),
                    brand = translatedBrand.logIfParseNull(Parser::hanimePreview.name, "$title brand"),
                    releaseDate = releaseDate.logIfParseNull(
                        Parser::hanimePreview.name,
                        "$title releaseDate"
                    ),
                    videoCode = videoCode.logIfParseNull(
                        Parser::hanimePreview.name,
                        "$title videoCode"
                    ),
                    tags = translatedTags,
                    relatedPicsUrl = relatedPics
                )
            )
        }

        val header = parseBody.selectFirst("div[id=player-div-wrapper]")
        val headerPicUrl = header?.selectFirst("img")?.absUrl("src")
        val hasPrevious = parseBody.getElementsByClass("hidden-md hidden-lg").firstOrNull()
            ?.select("div[style*=left]")?.firstOrNull() != null
        val hasNext = parseBody.getElementsByClass("hidden-md hidden-lg").firstOrNull()
            ?.select("div[style*=right]")?.firstOrNull() != null

        return WebsiteState.Success(
            HanimePreview(
                headerPicUrl = headerPicUrl.logIfParseNull(
                    Parser::hanimePreview.name,
                    "headerPicUrl"
                ),
                hasPrevious = hasPrevious,
                hasNext = hasNext,
                latestHanime = latestHanimeList,
                previewInfo = previewInfo
            )
        )
    }

    fun myListItems(body: String): PageLoadingState<MyListItems<HanimeInfo>> {
        val parseBody = Jsoup.parse(body).body()
        val csrfToken = parseBody.selectFirst("input[name=_token]")?.attr("value")
        val desc = parseBody.getElementById("playlist-show-description")?.ownText()
        val allHanimeClass = parseBody.getElementsByClass("horizontal-row").firstOrNull()
        val myListHanimeList = allHanimeClass.extractHanimeInfo("div[class^=user-tab-item-wrapper]")
        
        // Translate description if enabled
        val translatedDesc = desc?.let {
            runBlocking {
                translateIfEnabled(it, TranslationCache.ContentType.DESCRIPTION)
            }
        } ?: desc

        return PageLoadingState.Success(
            MyListItems(
                myListHanimeList,
                desc = translatedDesc,
                csrfToken = csrfToken
            )
        )
    }

    fun myPlayListItems(body: String): PageLoadingState<MyListItems<HanimeInfo>> {
        val parseBody = Jsoup.parse(body).body()
        val csrfToken = parseBody.selectFirst("input[name=_token]")?.attr("value")
        val desc = parseBody.select("p.playlist-description").first()?.text()
        val allHanimeClass = parseBody.getElementsByClass("playlist-video-list").firstOrNull()
        val myListHanimeList = allHanimeClass.extractHanimeInfo("div[class^=user-tab-item-wrapper]")
        
        // Translate description if enabled
        val translatedDesc = desc?.let {
            runBlocking {
                translateIfEnabled(it, TranslationCache.ContentType.DESCRIPTION)
            }
        } ?: desc

        return PageLoadingState.Success(
            MyListItems(
                myListHanimeList,
                desc = translatedDesc,
                csrfToken = csrfToken
            )
        )
    }


    fun playlists(body: String): WebsiteState<Playlists> {
        val parseBody = Jsoup.parse(body).body()
        val csrfToken = parseBody.selectFirst("input[name=_token]")?.attr("value")
        val lists = parseBody.getElementsByClass("user-tab-item-wrapper")
        val playlists = mutableListOf<Playlists.Playlist>()
        lists.forEach {
            val listCode = it.selectFirst("a[class=video-link]")?.absUrl("href")?.substringAfter('=')
                .throwIfParseNull(Parser::playlists.name, "listCode")
            val listTitle = it.selectFirst("div[class=title]")?.ownText()
                .throwIfParseNull(Parser::playlists.name, "listTitle")
            val listTotal = it.selectFirst("div[class=stat-item]")?.text()
            val formatedTotal = listTotal?.filter { char -> char.isDigit() }?.toIntOrNull() ?: -1
            val coverUrl = it.select("img[class=main-thumb]").first()?.attr("src")
            
            // Translate playlist title if enabled
            val translatedListTitle = runBlocking {
                translateIfEnabled(listTitle, TranslationCache.ContentType.OTHER, listCode)
            }
            
            playlists += Playlists.Playlist(
                listCode = listCode, 
                title = translatedListTitle, 
                total = formatedTotal, 
                coverUrl = coverUrl
            )
        }
        return WebsiteState.Success(Playlists(playlists = playlists, csrfToken = csrfToken))
    }

    @SuppressLint("BuildListAdds")
    fun comments(body: String): WebsiteState<VideoComments> {
        val jsonObject = JSONObject(body)
        val commentBody = jsonObject.get("comments").toString()
        val parseBody = Jsoup.parse(commentBody).body()
        val csrfToken = parseBody.selectFirst("input[name=_token]")?.attr("value")
        val currentUserId = parseBody.selectFirst("input[name=comment-user-id]")?.attr("value")
        val commentList = mutableListOf<VideoComments.VideoComment>()
        val allCommentsClass = parseBody.getElementById("comment-start")

        buildList {
            allCommentsClass?.children()?.chunked(4)?.forEach { elements ->
                add(Element("div").apply { appendChildren(elements) })
            }
        }.forEach { child: Element ->
            val avatarUrl = child.selectFirst("img")?.absUrl("src")
                .throwIfParseNull(Parser::comments.name, "avatarUrl")
            val textClass = child.getElementsByClass("comment-index-text")
            val nameAndDateClass = textClass.firstOrNull()
            val username = nameAndDateClass?.selectFirst("a")?.ownText()?.trim()
                .throwIfParseNull(Parser::comments.name, "username")
            val date = nameAndDateClass?.selectFirst("span")?.ownText()?.trim()
                .throwIfParseNull(Parser::comments.name, "date")
            val content = textClass.getOrNull(1)?.text()
                .throwIfParseNull(Parser::comments.name, "content")
            val hasMoreReplies = child.selectFirst("div[class^=load-replies-btn]") != null
            val thumbUp = child.getElementById("comment-like-form-wrapper")
                ?.select("span[style]")?.getOrNull(1)
                ?.text()?.toIntOrNull()
            val id = child.selectFirst("div[id^=reply-section-wrapper]")
                ?.id()?.substringAfterLast("-")

            val foreignId = child.getElementById("foreign_id")?.attr("value")
            val isPositive = child.getElementById("is_positive")?.attr("value")
            val likeUserId = child.selectFirst("input[name=comment-like-user-id]")?.attr("value")
            val commentLikesCount =
                child.selectFirst("input[name=comment-likes-count]")?.attr("value")
            val commentLikesSum = child.selectFirst("input[name=comment-likes-sum]")?.attr("value")
            val likeCommentStatus =
                child.selectFirst("input[name=like-comment-status]")?.attr("value")
            val unlikeCommentStatus =
                child.selectFirst("input[name=unlike-comment-status]")?.attr("value")

            val post = VideoComments.VideoComment.POST(
                foreignId.logIfParseNull(Parser::comments.name, "foreignId", loginNeeded = true),
                isPositive == "1",
                likeUserId.logIfParseNull(Parser::comments.name, "likeUserId", loginNeeded = true),
                commentLikesCount?.toIntOrNull().logIfParseNull(
                    Parser::comments.name,
                    "commentLikesCount", loginNeeded = true
                ),
                commentLikesSum?.toIntOrNull().logIfParseNull(
                    Parser::comments.name,
                    "commentLikesSum", loginNeeded = true
                ),
                likeCommentStatus == "1",
                unlikeCommentStatus == "1",
            )
            val regex = """\d+""".toRegex()
            val replyCountText = child.select("div.load-replies-btn").text()
            val replyCount = regex.find(replyCountText)?.value?.toInt()
            val reportRedirectUrl = ""
            val reportableId = child.select("span.report-btn").first()?.attr("data-reportable-id")
            val reportableType = child.select("span.report-btn").first()?.attr("data-reportable-type")
            
            // Translate comment content if enabled
            val translatedContent = runBlocking {
                translateIfEnabled(content, TranslationCache.ContentType.COMMENT, id)
            }
            
            commentList.add(
                VideoComments.VideoComment(
                    avatar = avatarUrl, 
                    username = username, 
                    date = date,
                    content = translatedContent, 
                    hasMoreReplies = hasMoreReplies, 
                    replyCount = replyCount,
                    thumbUp = thumbUp.logIfParseNull(Parser::comments.name, "thumbUp"),
                    id = id.logIfParseNull(Parser::comments.name, "id"),
                    isChildComment = false, 
                    post = post,
                    redirectUrl = reportRedirectUrl, 
                    reportableId = reportableId, 
                    reportableType = reportableType
                )
            )
        }
        Log.d("commentList", commentList.toString())
        return WebsiteState.Success(
            VideoComments(
                commentList,
                currentUserId,
                csrfToken
            )
        )
    }

    fun commentReply(body: String): WebsiteState<VideoComments> {
        val jsonObject = JSONObject(body)
        val replyBody = jsonObject.get("replies").toString()
        val replyList = mutableListOf<VideoComments.VideoComment>()
        val parseBody = Jsoup.parse(replyBody).body()
        val replyStart = parseBody.selectFirst("div[id^=reply-start]")
        replyStart?.let {
            val allRepliesClass = it.children()
            for (i in allRepliesClass.indices step 2) {
                val basicClass = allRepliesClass.getOrNull(i)
                val postClass = allRepliesClass.getOrNull(i + 1)

                val avatarUrl = basicClass?.selectFirst("img")?.absUrl("src")
                    .throwIfParseNull(Parser::commentReply.name, "avatarUrl")
                val textClass = basicClass?.getElementsByClass("comment-index-text")
                val nameAndDateClass = textClass?.firstOrNull()
                val username = nameAndDateClass?.selectFirst("a")?.ownText()?.trim()
                    .throwIfParseNull(Parser::commentReply.name, "name")
                val date = nameAndDateClass?.selectFirst("span")?.ownText()?.trim()
                    .throwIfParseNull(Parser::commentReply.name, "date")
                val content = textClass?.getOrNull(1)?.text()
                    .throwIfParseNull(Parser::commentReply.name, "content")
                val thumbUp = postClass
                    ?.select("span[style]")?.getOrNull(1)
                    ?.text()?.toIntOrNull()

                val foreignId =
                    postClass?.getElementById("foreign_id")?.attr("value")
                val isPositive =
                    postClass?.getElementById("is_positive")?.attr("value")
                val likeUserId =
                    postClass?.selectFirst("input[name=comment-like-user-id]")?.attr("value")
                val commentLikesCount =
                    postClass?.selectFirst("input[name=comment-likes-count]")?.attr("value")
                val commentLikesSum =
                    postClass?.selectFirst("input[name=comment-likes-sum]")?.attr("value")
                val likeCommentStatus =
                    postClass?.selectFirst("input[name=like-comment-status]")?.attr("value")
                val unlikeCommentStatus =
                    postClass?.selectFirst("input[name=unlike-comment-status]")?.attr("value")
                val post = VideoComments.VideoComment.POST(
                    foreignId.logIfParseNull(
                        Parser::commentReply.name,
                        "foreignId",
                        loginNeeded = true
                    ),
                    isPositive == "1",
                    likeUserId.logIfParseNull(
                        Parser::commentReply.name,
                        "likeUserId",
                        loginNeeded = true
                    ),
                    commentLikesCount?.toIntOrNull().logIfParseNull(
                        Parser::commentReply.name,
                        "commentLikesCount", loginNeeded = true
                    ),
                    commentLikesSum?.toIntOrNull().logIfParseNull(
                        Parser::commentReply.name,
                        "commentLikesSum", loginNeeded = true
                    ),
                    likeCommentStatus == "1",
                    unlikeCommentStatus == "1",
                )
                val reportRedirectUrl = ""
                val reportableId = basicClass?.select("span.report-btn")?.first()?.attr("data-reportable-id")
                val reportableType = basicClass?.select("span.report-btn")?.first()?.attr("data-reportable-type")
                
                // Translate reply content if enabled
                val translatedContent = content?.let {
                    runBlocking {
                        translateIfEnabled(it, TranslationCache.ContentType.COMMENT)
                    }
                } ?: content
                
                replyList.add(
                    VideoComments.VideoComment(
                        avatar = avatarUrl, 
                        username = username, 
                        date = date,
                        content = translatedContent,
                        thumbUp = thumbUp.logIfParseNull(Parser::commentReply.name, "thumbUp"),
                        id = null,
                        isChildComment = true, 
                        post = post, 
                        reportableId = reportableId,
                        reportableType = reportableType, 
                        redirectUrl = reportRedirectUrl
                    )
                )
            }
        }

        return WebsiteState.Success(VideoComments(replyList))
    }

    fun reportCommentResponse(body: String): WebsiteState<String> {
        return if (body.contains("已成功檢舉該則評論")) {
            WebsiteState.Success("已成功檢舉該則評論，我們會儘快處理您的檢舉。")
        } else {
            val doc = Jsoup.parse(body)
            val msg = doc.select("#error").text()
            if (msg.contains("已成功檢舉")) {
                WebsiteState.Success(msg)
            } else {
                WebsiteState.Error(Throwable("举报失败或未检测到成功提示"))
            }
        }
    }

    fun getMySubscriptions(body: String): WebsiteState<MySubscriptions> {
        val parseBody = Jsoup.parse(body).body()
        val maxPage = parseMaxPage(parseBody)
        Log.i("getMySubscriptions", "MaxPageList=$maxPage")
        val subscriptionsRoot = parseBody.selectFirst("div.subscriptions-nav")
            ?: return WebsiteState.Error(IllegalStateException("找不到 subscriptions-nav"))
        val subscriptionsVideosRoot = parseBody.selectFirst("div.content-padding-new")
            ?: return WebsiteState.Error(IllegalStateException("找不到 subscriptionsVideosRoot"))

        // 解析订阅作者
        val artists = subscriptionsRoot.select("div.subscriptions-artist-card").mapNotNull { card ->
            try {
                val imgs = card.select("img")
                val avatarSrc = imgs.getOrNull(1)?.absUrl("src") ?: return@mapNotNull null
                val artistName = card.selectFirst("div.card-mobile-title")?.text()?.trim()
                    ?: return@mapNotNull null
                    
                // Translate artist name if enabled
                val translatedArtistName = runBlocking {
                    translateIfEnabled(artistName, TranslationCache.ContentType.ARTIST_NAME)
                }

                SubscriptionItem(
                    artistName = translatedArtistName,
                    avatar = avatarSrc
                )
            } catch (_: Exception) {
                null
            }
        }

        // 解析订阅视频
        val videos = subscriptionsVideosRoot.select("div[class^=video-item-container]")
            .mapNotNull { videoCard ->
                try {
                    val link =
                        videoCard.selectFirst("a[class^=video-link]")?.absUrl("href") ?: return@mapNotNull null
                    val videoCode = Regex("""watch\?v=(\d+)""").find(link)?.groupValues?.get(1)
                        ?: return@mapNotNull null
                    val coverUrl = videoCard.select("img[class^=main-thumb]").getOrNull(0)?.absUrl("src") ?: return@mapNotNull null
                    val title = videoCard.attr("title").trim()
                    val durationAndViews = videoCard.select("div[class^=thumb-container]")
                    val duration = durationAndViews.select("div[class^=duration]").text()
                    val views = durationAndViews.select("div[class^=stat-item]").getOrNull(1)?.text()
                    val artistAndUploadTime = videoCard.select("div.subtitle a").text().trim()
                    var artist = ""
                    var uploadTime = ""
                    if (artistAndUploadTime.contains("•")) {
                        val parts = artistAndUploadTime.split("•").map { it.trim() }
                        artist = parts[0].trim()
                        uploadTime = parts[1].trim()
                    }
                    val infoBoxes = videoCard.selectFirst(".stats-container .stat-item")
                    val fullText = infoBoxes?.text() ?: ""
                    val reviews = fullText.replace("thumb_up", "").trim()
                    
                    // Translate title and artist if enabled
                    val translatedTitle = runBlocking {
                        translateIfEnabled(title, TranslationCache.ContentType.TITLE, videoCode)
                    }
                    
                    val translatedArtist = if (artist.isNotBlank()) {
                        runBlocking {
                            translateIfEnabled(artist, TranslationCache.ContentType.ARTIST_NAME, videoCode)
                        }
                    } else artist

                    SubscriptionVideosItem(
                        title = translatedTitle,
                        coverUrl = coverUrl,
                        videoCode = videoCode,
                        duration = duration,
                        views = views,
                        reviews = reviews,
                        currentArtist = translatedArtist,
                        uploadTime = uploadTime
                    )
                } catch (_: Exception) {
                    null
                }
            }

        return WebsiteState.Success(
            MySubscriptions(
                subscriptions = artists,
                subscriptionsVideos = videos,
                maxPage = maxPage
            )
        )
    }

    private fun parseMaxPage(parseBody: Element): Int {
        return parseBody
            .select("ul.pagination")
            .lastOrNull()
            ?.select("a.page-link[href]")
            ?.mapNotNull {
                Regex("""\?page=(\d+)""").find(it.attr("href"))?.groupValues?.get(1)?.toIntOrNull()
            }
            ?.maxOrNull() ?: 1
    }

    /**
     * 這個網站的網頁結構真的很奇怪，所以我寫了一個 forEachStep2 來處理
     */
    private inline fun Elements.forEachStep2(action: (Element) -> Unit) {
        for (i in 0 until size step 2) {
            action(get(i))
        }
    }

    /**
     * 得到 Element 的 child，如果 index 超出範圍，就返回 null
     */
    private fun Element.childOrNull(index: Int): Element? {
        return try {
            child(index)
        } catch (_: IndexOutOfBoundsException) {
            null
        }
    }

    /**
     * 基本都是必需的參數，所以如果是 null，就直接丟出 [ParseException]
     *
     * @param funcName 這個參數是在哪個函數中被使用的
     * @param varName 這個參數的名稱
     * @return 如果 [this] 不是 null，就回傳 [this]
     * @throws ParseException 如果 [this] 是 null，就丟出 [ParseException]
     */
    private fun <T> T?.throwIfParseNull(funcName: String, varName: String): T = this
        ?: throw ParseException(funcName, varName)

    /**
     * 如果 [this] 是 null，就在 logcat 中顯示訊息
     *
     * @param funcName 這個參數是在哪個函數中被使用的
     * @param varName 這個參數的名稱
     * @return 回傳 [this]
     */
    private fun <T> T?.logIfParseNull(
        funcName: String, varName: String, loginNeeded: Boolean = false,
    ): T? = also {
        if (it == null) {
            if (loginNeeded) {
                if (isAlreadyLogin) {
                    Log.d("Parse::$funcName", "[$varName] is null. 而且處於登入狀態，這有點不正常")
                }
            } else {
                Log.d("Parse::$funcName", "[$varName] is null. 這有點不正常")
            }
        }
    }
}

Step 9: Add Translation to ViewModels

Create a wrapper for views to handle translation:

Create app/src/main/java/com/yenaly/han1meviewer/ui/view/TranslatedTextView.kt:

```kotlin
package com.yenaly.han1meviewer.ui.view

import android.content.Context
import android.util.AttributeSet
import androidx.appcompat.widget.AppCompatTextView
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.lifecycleScope
import com.yenaly.han1meviewer.logic.TranslationCache
import com.yenaly.han1meviewer.logic.TranslationManager
import kotlinx.coroutines.launch

class TranslatedTextView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : AppCompatTextView(context, attrs, defStyleAttr) {
    
    private var originalText: String = ""
    private var contentType: TranslationCache.ContentType = TranslationCache.ContentType.OTHER
    private var videoCode: String? = null
    
    fun setTranslatedText(
        text: String,
        contentType: TranslationCache.ContentType,
        videoCode: String? = null,
        lifecycleOwner: LifecycleOwner? = null
    ) {
        this.originalText = text
        this.contentType = contentType
        this.videoCode = videoCode
        
        if (lifecycleOwner != null) {
            lifecycleOwner.lifecycleScope.launch {
                val translationManager = TranslationManager.getInstance(context)
                val translated = translationManager.translate(text, contentType, videoCode)
                setText(translated)
            }
        } else {
            setText(text)
        }
    }
    
    fun getOriginalText(): String = originalText
}
```
add

// In HanimeApplication.kt or MainActivity.kt
Parser.initialize(this)
Step 10: Add Menu Resources

Create app/src/main/res/menu/menu_translation_cache.xml:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    
    <item
        android:id="@+id/action_stats"
        android:title="Statistics"
        android:icon="@drawable/ic_baseline_data_usage_24"
        app:showAsAction="ifRoom" />
    
    <item
        android:id="@+id/action_clear_all"
        android:title="Clear All"
        android:icon="@drawable/ic_baseline_clear_all_24"
        app:showAsAction="ifRoom" />
    
    <item
        android:id="@+id/action_refresh"
        android:title="Refresh"
        android:icon="@drawable/baseline_refresh_24"
        app:showAsAction="ifRoom" />
    
</menu>
```

Step 11: Update Settings Activity

Add translation settings to your SettingsActivity or router:

```kotlin
// In SettingsRouter or SettingsActivity
.addPreferenceFragment(
    title = "Translation",
    fragment = TranslationSettingsFragment::class.java,
    icon = R.drawable.ic_baseline_translate_24 // Add this icon
)
```

Step 12: Initialize Translation Manager

In your HanimeApplication.kt or main activity:

```kotlin
override fun onCreate() {
    super.onCreate()
    
    // Initialize translation manager
    TranslationManager.getInstance(this).initialize()
}
```

Step 13: Add Migration for Existing Users

Create a migration script in your database or preferences:

```kotlin
fun migrateToTranslationSettings() {
    // Check if old translation settings exist and migrate them
}
```

Summary of Implementation:

1. Core Translation Manager (TranslationManager.kt) - Handles API calls, batching, caching, and multi-key fallback
2. Database Layer - Room entities for caching translations
3. Settings UI - User preferences for API keys, limits, and what to translate
4. Cache Management UI - View, edit, delete cached translations
5. Integration with Parser - Automatic translation during parsing
6. Custom Views - TranslatedTextView for easy integration
7. Statistics - Track usage per API key and content type

Key Features Implemented:

· Multi-API Key Support: Rotate through multiple keys with fallback
· Smart Batching: Automatically batch texts respecting character limits
· Caching System: Store translations locally to save API quota
· Content Type Control: Choose what to translate (titles, descriptions, etc.)
· Monthly Limits: Automatic reset and quota tracking
· Cache Management: View, edit, delete cached translations
· Statistics: Track usage and remaining quota

This implementation is modular and can be easily extended. The translation happens automatically in the background, and cached translations are reused, minimizing API calls.